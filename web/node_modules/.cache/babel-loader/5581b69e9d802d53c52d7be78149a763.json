{"ast":null,"code":"/***\n * @license\n * https://github.com/bitcoincashjs/bchaddr\n * Copyright (c) 2018 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\nvar bs58check = require('bs58check');\n\nvar cashaddr = require('cashaddrjs');\n/**\n * General purpose Bitcoin Cash address detection and translation.<br />\n * Supports all major Bitcoin Cash address formats.<br />\n * Currently:\n * <ul>\n *    <li> Legacy format </li>\n *    <li> Bitpay format </li>\n *    <li> Cashaddr format </li>\n * </ul>\n * @module bchaddr\n */\n\n/**\n * @static\n * Supported Bitcoin Cash address formats.\n */\n\n\nvar Format = {};\nFormat.Legacy = 'legacy';\nFormat.Bitpay = 'bitpay';\nFormat.Cashaddr = 'cashaddr';\n/**\n * @static\n * Supported networks.\n */\n\nvar Network = {};\nNetwork.Mainnet = 'mainnet';\nNetwork.Testnet = 'testnet';\n/**\n * @static\n * Supported address types.\n */\n\nvar Type = {};\nType.P2PKH = 'p2pkh';\nType.P2SH = 'p2sh';\n/**\n * Detects what is the given address' format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\n\nfunction detectAddressFormat(address) {\n  return decodeAddress(address).format;\n}\n/**\n * Detects what is the given address' network.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\n\n\nfunction detectAddressNetwork(address) {\n  return decodeAddress(address).network;\n}\n/**\n * Detects what is the given address' type.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\n\n\nfunction detectAddressType(address) {\n  return decodeAddress(address).type;\n}\n/**\n * Translates the given address into legacy format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\n\n\nfunction toLegacyAddress(address) {\n  var decoded = decodeAddress(address);\n\n  if (decoded.format === Format.Legacy) {\n    return address;\n  }\n\n  return encodeAsLegacy(decoded);\n}\n/**\n * Translates the given address into bitpay format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\n\n\nfunction toBitpayAddress(address) {\n  var decoded = decodeAddress(address);\n\n  if (decoded.format === Format.Bitpay) {\n    return address;\n  }\n\n  return encodeAsBitpay(decoded);\n}\n/**\n * Translates the given address into cashaddr format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\n\n\nfunction toCashAddress(address) {\n  var decoded = decodeAddress(address);\n  return encodeAsCashaddr(decoded);\n}\n/**\n * Version byte table for base58 formats.\n * @private\n */\n\n\nvar VERSION_BYTE = {};\nVERSION_BYTE[Format.Legacy] = {};\nVERSION_BYTE[Format.Legacy][Network.Mainnet] = {};\nVERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH] = 0;\nVERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH] = 5;\nVERSION_BYTE[Format.Legacy][Network.Testnet] = {};\nVERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH] = 111;\nVERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH] = 196;\nVERSION_BYTE[Format.Bitpay] = {};\nVERSION_BYTE[Format.Bitpay][Network.Mainnet] = {};\nVERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH] = 28;\nVERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH] = 40;\nVERSION_BYTE[Format.Bitpay][Network.Testnet] = {};\nVERSION_BYTE[Format.Bitpay][Network.Testnet][Type.P2PKH] = 111;\nVERSION_BYTE[Format.Bitpay][Network.Testnet][Type.P2SH] = 196;\n/**\n * Decodes the given address into its constituting hash, format, network and type.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\n\nfunction decodeAddress(address) {\n  try {\n    return decodeBase58Address(address);\n  } catch (error) {}\n\n  try {\n    return decodeCashAddress(address);\n  } catch (error) {}\n\n  throw new InvalidAddressError();\n}\n/**\n * Length of a valid base58check encoding payload: 1 byte for\n * the version byte plus 20 bytes for a RIPEMD-160 hash.\n * @private\n */\n\n\nvar BASE_58_CHECK_PAYLOAD_LENGTH = 21;\n/**\n * Attempts to decode the given address assuming it is a base58 address.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\n\nfunction decodeBase58Address(address) {\n  try {\n    var payload = bs58check.decode(address);\n\n    if (payload.length !== BASE_58_CHECK_PAYLOAD_LENGTH) {\n      throw new InvalidAddressError();\n    }\n\n    var versionByte = payload[0];\n    var hash = Array.prototype.slice.call(payload, 1);\n\n    switch (versionByte) {\n      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Mainnet,\n          type: Type.P2PKH\n        };\n\n      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Mainnet,\n          type: Type.P2SH\n        };\n\n      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Testnet,\n          type: Type.P2PKH\n        };\n\n      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Testnet,\n          type: Type.P2SH\n        };\n\n      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Bitpay,\n          network: Network.Mainnet,\n          type: Type.P2PKH\n        };\n\n      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Bitpay,\n          network: Network.Mainnet,\n          type: Type.P2SH\n        };\n    }\n  } catch (error) {}\n\n  throw new InvalidAddressError();\n}\n/**\n * Attempts to decode the given address assuming it is a cashaddr address.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\n\n\nfunction decodeCashAddress(address) {\n  if (address.indexOf(':') !== -1) {\n    try {\n      return decodeCashAddressWithPrefix(address);\n    } catch (error) {}\n  } else {\n    var prefixes = ['bitcoincash', 'bchtest', 'bchreg'];\n\n    for (var i = 0; i < prefixes.length; ++i) {\n      try {\n        var prefix = prefixes[i];\n        return decodeCashAddressWithPrefix(prefix + ':' + address);\n      } catch (error) {}\n    }\n  }\n\n  throw new InvalidAddressError();\n}\n/**\n * Attempts to decode the given address assuming it is a cashaddr address with explicit prefix.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\n\n\nfunction decodeCashAddressWithPrefix(address) {\n  try {\n    var decoded = cashaddr.decode(address);\n    var hash = Array.prototype.slice.call(decoded.hash, 0);\n    var type = decoded.type === 'P2PKH' ? Type.P2PKH : Type.P2SH;\n\n    switch (decoded.prefix) {\n      case 'bitcoincash':\n        return {\n          hash: hash,\n          format: Format.Cashaddr,\n          network: Network.Mainnet,\n          type: type\n        };\n\n      case 'bchtest':\n      case 'bchreg':\n        return {\n          hash: hash,\n          format: Format.Cashaddr,\n          network: Network.Testnet,\n          type: type\n        };\n    }\n  } catch (error) {}\n\n  throw new InvalidAddressError();\n}\n/**\n * Encodes the given decoded address into legacy format.\n * @private\n * @param {object} decoded\n * @returns {string}\n */\n\n\nfunction encodeAsLegacy(decoded) {\n  var versionByte = VERSION_BYTE[Format.Legacy][decoded.network][decoded.type];\n  var buffer = Buffer.alloc(1 + decoded.hash.length);\n  buffer[0] = versionByte;\n  buffer.set(decoded.hash, 1);\n  return bs58check.encode(buffer);\n}\n/**\n * Encodes the given decoded address into bitpay format.\n * @private\n * @param {object} decoded\n * @returns {string}\n */\n\n\nfunction encodeAsBitpay(decoded) {\n  var versionByte = VERSION_BYTE[Format.Bitpay][decoded.network][decoded.type];\n  var buffer = Buffer.alloc(1 + decoded.hash.length);\n  buffer[0] = versionByte;\n  buffer.set(decoded.hash, 1);\n  return bs58check.encode(buffer);\n}\n/**\n * Encodes the given decoded address into cashaddr format.\n * @private\n * @param {object} decoded\n * @returns {string}\n */\n\n\nfunction encodeAsCashaddr(decoded) {\n  var prefix = decoded.network === Network.Mainnet ? 'bitcoincash' : 'bchtest';\n  var type = decoded.type === Type.P2PKH ? 'P2PKH' : 'P2SH';\n  var hash = new Uint8Array(decoded.hash);\n  return cashaddr.encode(prefix, type, hash);\n}\n/**\n * Returns a boolean indicating whether the address is in legacy format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\n\n\nfunction isLegacyAddress(address) {\n  return detectAddressFormat(address) === Format.Legacy;\n}\n/**\n * Returns a boolean indicating whether the address is in bitpay format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\n\n\nfunction isBitpayAddress(address) {\n  return detectAddressFormat(address) === Format.Bitpay;\n}\n/**\n * Returns a boolean indicating whether the address is in cashaddr format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\n\n\nfunction isCashAddress(address) {\n  return detectAddressFormat(address) === Format.Cashaddr;\n}\n/**\n * Returns a boolean indicating whether the address is a mainnet address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\n\n\nfunction isMainnetAddress(address) {\n  return detectAddressNetwork(address) === Network.Mainnet;\n}\n/**\n * Returns a boolean indicating whether the address is a testnet address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\n\n\nfunction isTestnetAddress(address) {\n  return detectAddressNetwork(address) === Network.Testnet;\n}\n/**\n * Returns a boolean indicating whether the address is a p2pkh address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\n\n\nfunction isP2PKHAddress(address) {\n  return detectAddressType(address) === Type.P2PKH;\n}\n/**\n * Returns a boolean indicating whether the address is a p2sh address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\n\n\nfunction isP2SHAddress(address) {\n  return detectAddressType(address) === Type.P2SH;\n}\n/**\n * Error thrown when the address given as input is not a valid Bitcoin Cash address.\n * @constructor\n * InvalidAddressError\n */\n\n\nfunction InvalidAddressError() {\n  var error = new Error();\n  this.name = error.name = 'InvalidAddressError';\n  this.message = error.message = 'Received an invalid Bitcoin Cash address as input.';\n  this.stack = error.stack;\n}\n\nInvalidAddressError.prototype = Object.create(Error.prototype);\nmodule.exports = {\n  Format: Format,\n  Network: Network,\n  Type: Type,\n  detectAddressFormat: detectAddressFormat,\n  detectAddressNetwork: detectAddressNetwork,\n  detectAddressType: detectAddressType,\n  toLegacyAddress: toLegacyAddress,\n  toBitpayAddress: toBitpayAddress,\n  toCashAddress: toCashAddress,\n  isLegacyAddress: isLegacyAddress,\n  isBitpayAddress: isBitpayAddress,\n  isCashAddress: isCashAddress,\n  isMainnetAddress: isMainnetAddress,\n  isTestnetAddress: isTestnetAddress,\n  isP2PKHAddress: isP2PKHAddress,\n  isP2SHAddress: isP2SHAddress,\n  InvalidAddressError: InvalidAddressError\n};","map":null,"metadata":{},"sourceType":"script"}