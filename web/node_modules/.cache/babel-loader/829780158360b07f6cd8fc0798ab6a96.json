{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport classNames from 'classnames';\nimport omit from 'omit.js';\nimport * as React from 'react';\nimport { polyfill } from 'react-lifecycles-compat';\nimport RcMentions from 'rc-mentions';\nimport Spin from '../spin';\nimport { ConfigConsumer } from '../config-provider';\nvar Option = RcMentions.Option;\n\nfunction loadingFilterOption() {\n  return true;\n}\n\nvar Mentions =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Mentions, _React$Component);\n\n  function Mentions() {\n    var _this;\n\n    _classCallCheck(this, Mentions);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Mentions).apply(this, arguments));\n    _this.state = {\n      focused: false\n    };\n\n    _this.onFocus = function () {\n      var onFocus = _this.props.onFocus;\n\n      if (onFocus) {\n        onFocus.apply(void 0, arguments);\n      }\n\n      _this.setState({\n        focused: true\n      });\n    };\n\n    _this.onBlur = function () {\n      var onBlur = _this.props.onBlur;\n\n      if (onBlur) {\n        onBlur.apply(void 0, arguments);\n      }\n\n      _this.setState({\n        focused: false\n      });\n    };\n\n    _this.getOptions = function () {\n      var _this$props = _this.props,\n          children = _this$props.children,\n          loading = _this$props.loading;\n\n      if (loading) {\n        return React.createElement(Option, {\n          value: \"ANTD_SEARCHING\",\n          disabled: true\n        }, React.createElement(Spin, {\n          size: \"small\"\n        }));\n      }\n\n      return children;\n    };\n\n    _this.getFilterOption = function () {\n      var _this$props2 = _this.props,\n          filterOption = _this$props2.filterOption,\n          loading = _this$props2.loading;\n\n      if (loading) {\n        return loadingFilterOption;\n      }\n\n      return filterOption;\n    };\n\n    _this.saveMentions = function (node) {\n      _this.rcMentions = node;\n    };\n\n    _this.renderMentions = function (_ref) {\n      var _classNames;\n\n      var getPrefixCls = _ref.getPrefixCls,\n          renderEmpty = _ref.renderEmpty;\n      var focused = _this.state.focused;\n\n      var _a = _this.props,\n          customizePrefixCls = _a.prefixCls,\n          className = _a.className,\n          disabled = _a.disabled,\n          restProps = __rest(_a, [\"prefixCls\", \"className\", \"disabled\"]);\n\n      var prefixCls = getPrefixCls('mentions', customizePrefixCls);\n      var mentionsProps = omit(restProps, ['loading']);\n      var mergedClassName = classNames(className, (_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-disabled\"), disabled), _defineProperty(_classNames, \"\".concat(prefixCls, \"-focused\"), focused), _classNames));\n      return React.createElement(RcMentions, _extends({\n        prefixCls: prefixCls,\n        notFoundContent: _this.getNotFoundContent(renderEmpty),\n        className: mergedClassName,\n        disabled: disabled\n      }, mentionsProps, {\n        filterOption: _this.getFilterOption(),\n        onFocus: _this.onFocus,\n        onBlur: _this.onBlur,\n        ref: _this.saveMentions\n      }), _this.getOptions());\n    };\n\n    return _this;\n  }\n\n  _createClass(Mentions, [{\n    key: \"getNotFoundContent\",\n    value: function getNotFoundContent(renderEmpty) {\n      var notFoundContent = this.props.notFoundContent;\n\n      if (notFoundContent !== undefined) {\n        return notFoundContent;\n      }\n\n      return renderEmpty('Select');\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this.rcMentions.focus();\n    }\n  }, {\n    key: \"blur\",\n    value: function blur() {\n      this.rcMentions.blur();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(ConfigConsumer, null, this.renderMentions);\n    }\n  }]);\n\n  return Mentions;\n}(React.Component);\n\nMentions.Option = Option;\n\nMentions.getMentions = function () {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var config = arguments.length > 1 ? arguments[1] : undefined;\n\n  var _ref2 = config || {},\n      _ref2$prefix = _ref2.prefix,\n      prefix = _ref2$prefix === void 0 ? '@' : _ref2$prefix,\n      _ref2$split = _ref2.split,\n      split = _ref2$split === void 0 ? ' ' : _ref2$split;\n\n  var prefixList = Array.isArray(prefix) ? prefix : [prefix];\n  return value.split(split).map(function () {\n    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var hitPrefix = null;\n    prefixList.some(function (prefixStr) {\n      var startStr = str.slice(0, prefixStr.length);\n\n      if (startStr === prefixStr) {\n        hitPrefix = prefixStr;\n        return true;\n      }\n\n      return false;\n    });\n\n    if (hitPrefix !== null) {\n      return {\n        prefix: hitPrefix,\n        value: str.slice(hitPrefix.length)\n      };\n    }\n\n    return null;\n  }).filter(function (entity) {\n    return !!entity && !!entity.value;\n  });\n};\n\npolyfill(Mentions);\nexport default Mentions;","map":null,"metadata":{},"sourceType":"module"}